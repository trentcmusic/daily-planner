<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Daily Planner</title>
<style>
  :root{
    --slot-h: 36px;
    --left-w: 260px;
    --bg: #f7f9ff;
    --grid-bg: #eef3ff;
    --line: #aabaff;
    --dash: #c6cff7;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--bg);height:100dvh;display:flex;overflow:hidden}
  @media(max-width:800px){body{flex-direction:column}}
  .column{overflow:auto;padding:14px}
  #todo{width:var(--left-w);min-width:220px;border-right:2px solid #dee2e6}
  @media(max-width:800px){#todo{width:100%;border-right:none;border-bottom:2px solid #dee2e6}}
  /* static holographic-ish foil (subtle/silvery) */
  .holographic-background{
    background:
      radial-gradient(1200px 600px at 10% 20%, rgba(255,255,255,.75), rgba(255,255,255,0) 60%),
      radial-gradient(900px 500px at 90% 30%, rgba(240,230,255,.55), rgba(255,255,255,0) 55%),
      radial-gradient(900px 600px at 30% 90%, rgba(220,250,255,.45), rgba(255,255,255,0) 60%),
      linear-gradient(135deg,#d9d9dc 0%,#f2f2f6 40%,#d9d9dc 100%);
  }
  #todo h2{font-size:26px;margin:4px 0 12px 0}
  #schedule{flex:1;background:var(--grid-bg);display:flex;flex-direction:column;min-width:0}
  #headerRow{display:flex;align-items:center;gap:12px;padding:14px 14px 8px 14px}
  #datePicker{padding:.35rem .5rem;border:1px solid #cfd6ff;border-radius:10px;background:#fff;font:inherit}
  #exportBtn{margin-left:auto;padding:.45rem .9rem;border:none;border-radius:10px;background:#4c6fff;color:#fff;font-weight:700;cursor:pointer}
  #exportBtn:hover{background:#355eff}
  #gridWrap{flex:1;min-height:0;padding:0 14px 14px 14px}
  #grid{display:grid;grid-template-columns:70px 1fr; height:100%; overflow:auto; background:transparent; border-radius:14px}
  /* hour labels column: one cell per hour (spans 4 slots) */
  .hour-label{
    height:calc(var(--slot-h)*4);
    line-height:calc(var(--slot-h)*4);
    text-align:right;padding-right:10px;
    color:#667; font-size:13px;
    border-bottom:1px solid rgba(170,186,255,.6);
    user-select:none;
  }
  .slot-col{position:relative}
  .slot{
    height:var(--slot-h);
    border-bottom:1px dashed var(--dash);
    position:relative;
    background:rgba(255,255,255,.35);
  }
  .slot:nth-child(4n){border-bottom:1px solid rgba(170,186,255,.75)}
  .slot.highlight{background:rgba(160,255,180,.35)}
  /* palette cards */
  .card{
    padding:10px 12px;margin:10px 0;border-radius:10px;
    color:#fff;font-weight:800;font-size:18px;
    cursor:grab; user-select:none; touch-action:none;
    box-shadow:0 1px 0 rgba(255,255,255,.25) inset;
  }
  /* category colors */
  .journaling{background:#ff9f43}.prayer{background:#5758BB}.gaming{background:#1B9CFC}.nap{background:#FDA7DF}
  .medicine{background:#e15f41}.handiwork{background:#2ecc71}.freetime{background:#3dc1d3}.dropoff{background:#34ace0}
  .therapy{background:#574b90}.bed{background:#2f3542}.appointment{background:#b33771}.chores{background:#9b59b6}

  /* scheduled event pill */
  .pill{
    position:absolute; left:2px; right:2px; top:2px;
    height:calc(var(--slot-h) - 4px);
    border-radius:8px;
    display:flex; align-items:center; justify-content:center;
    color:#fff; font-weight:800; font-size:13px;
    cursor:grab;
    white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    touch-action:none;
  }
  .pill .lbl{pointer-events:none; padding:0 10px}
  /* translucent resize bar */
  .pill .handle{
    position:absolute; left:0; right:0; bottom:0;
    height:8px;
    background:rgba(255,255,255,0.65);
    border-top:1px solid rgba(0,0,0,0.12);
    cursor:ns-resize;
    z-index:5;
    touch-action:none;
  }

  /* floating trash */
  #trash{
    position:fixed; right:18px; bottom:18px;
    width:64px; height:64px; border-radius:50%;
    background:#ff6b6b; display:flex; align-items:center; justify-content:center;
    font-size:28px; color:#fff;
    box-shadow:0 8px 22px rgba(0,0,0,.18);
    z-index:1000;
  }
  #trash.hover{background:#ff3b3b}

  /* toast undo */
  #toast{
    position:fixed; bottom:96px; left:50%; transform:translateX(-50%);
    background:#2c2c34; color:#fff; padding:10px 14px;
    border-radius:999px;
    display:flex; gap:12px; align-items:center;
    opacity:0; pointer-events:none; transition:opacity .18s;
    z-index:1001; font-size:14px;
  }
  #toast.show{opacity:1; pointer-events:auto}
  #toast button{
    background:none;border:none;color:#6fb4ff;font-weight:800;cursor:pointer
  }

  /* drag ghost */
  .drag-ghost{
    position:fixed; z-index:2000;
    transform:translate(-50%,-50%);
    pointer-events:none;
    opacity:.92;
    filter:drop-shadow(0 10px 18px rgba(0,0,0,.22));
  }
</style>
</head>
<body>
  <aside id="todo" class="column holographic-background">
    <h2>Actions</h2>
    <div class="card journaling" data-action="Journaling">Journaling</div>
    <div class="card prayer" data-action="Prayer &amp; Bible">Prayer &amp; Bible</div>
    <div class="card gaming" data-action="Gaming">Gaming</div>
    <div class="card nap" data-action="Nap">Nap</div>
    <div class="card medicine" data-action="Take Medicine">Take Medicine</div>
    <div class="card handiwork" data-action="Handiwork (No screens)">Handiwork (No screens)</div>
    <div class="card freetime" data-action="Free time">Free time</div>
    <div class="card dropoff" data-action="Dropoff/Pickup">Dropoff/Pickup</div>
    <div class="card therapy" data-action="Therapy">Therapy</div>
    <div class="card bed" data-action="Get ready for bed">Get ready for bed</div>
    <div class="card appointment" data-action="Appointment">Appointment</div>
    <div class="card chores" data-action="Chores">Chores</div>
  </aside>

  <section id="schedule" class="column" style="padding:0">
    <div id="headerRow">
      <input type="date" id="datePicker" />
      <button id="exportBtn">Export (.ics)</button>
    </div>
    <div id="gridWrap">
      <div id="grid" aria-label="Daily schedule grid"></div>
    </div>
  </section>

  <div id="trash" title="Drag here to delete">ðŸ—‘</div>
  <div id="toast">Deleted. <button id="undoBtn" type="button">Undo</button></div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const SLOT_H = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--slot-h')) || 36;
  const grid = document.getElementById('grid');
  const datePicker = document.getElementById('datePicker');
  const exportBtn = document.getElementById('exportBtn');
  const trash = document.getElementById('trash');
  const toast = document.getElementById('toast');
  const undoBtn = document.getElementById('undoBtn');

  // default date = today
  const today = new Date();
  datePicker.valueAsDate = today;

  const pad = (n) => String(n).padStart(2,'0');
  const hm12 = (hm) => {
    let h = parseInt(hm.slice(0,2),10);
    const m = hm.slice(2);
    const ap = h < 12 ? 'AM' : 'PM';
    h = h % 12; if (h === 0) h = 12;
    return `${h}:${m} ${ap}`;
  };
  const addM = (hm, min) => {
    const t = parseInt(hm.slice(0,2),10)*60 + parseInt(hm.slice(2),10) + min;
    const hh = (Math.floor(t/60) % 24 + 24) % 24;
    const mm = ((t % 60) + 60) % 60;
    return pad(hh) + pad(mm);
  };

  // Build 24h grid with 15-min slots
  function buildGrid(){
    grid.innerHTML = '';
    for(let h=0; h<24; h++){
      const lbl = document.createElement('div');
      lbl.className = 'hour-label';
      lbl.textContent = `${(h%12||12)} ${h<12?'AM':'PM'}`;
      grid.appendChild(lbl);

      const col = document.createElement('div');
      col.className = 'slot-col';
      grid.appendChild(col);

      for(let q=0; q<4; q++){
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.dataset.hm = pad(h) + pad(q*15);
        col.appendChild(slot);
      }
    }
  }
  buildGrid();

  // Helpers
  const allSlots = () => Array.from(document.querySelectorAll('.slot'));
  const slotFromPoint = (x,y) => {
    const el = document.elementFromPoint(x,y);
    if (!el) return null;
    if (el.classList.contains('slot')) return el;
    const s = el.closest && el.closest('.slot');
    return s || null;
  };

  function ensurePill(pill){
    if (!pill) return null;
    pill.classList.add('pill');
    pill.draggable = false; // we use pointer drag
    if (!pill.dataset.duration) pill.dataset.duration = '1';
    if (!pill.dataset.action){
      const t = (pill.textContent || '').trim();
      pill.dataset.action = t || 'Event';
    }

    // label
    let lbl = pill.querySelector('.lbl');
    if (!lbl){
      const txt = pill.dataset.action;
      pill.innerHTML = '';
      lbl = document.createElement('span');
      lbl.className = 'lbl';
      lbl.textContent = txt;
      pill.appendChild(lbl);
    }

    // handle
    let handle = pill.querySelector('.handle');
    if (!handle){
      handle = document.createElement('div');
      handle.className = 'handle';
      pill.appendChild(handle);
    }
    return pill;
  }

  function setPillHeight(pill){
    const dur = Math.max(1, Math.min(32, parseInt(pill.dataset.duration||'1',10)));
    pill.dataset.duration = String(dur);
    pill.style.height = `calc(var(--slot-h)*${dur} - 4px)`;
  }

  function refreshLabel(pill, slot){
    pill = ensurePill(pill);
    if (!pill || !slot) return;
    const lbl = pill.querySelector('.lbl');
    if (!lbl) return;
    const dur = Math.max(1, parseInt(pill.dataset.duration||'1',10));
    const sHM = slot.dataset.hm;
    const eHM = addM(sHM, dur*15);
    lbl.textContent = `${hm12(sHM)} â€“ ${hm12(eHM)} â€¢ ${pill.dataset.action}`;
  }

  function canPlace(slot, duration, ignorePill){
    // Enforce: no overlap â€” duration cannot run into another pill beneath.
    const slots = allSlots();
    const startIdx = slots.indexOf(slot);
    if (startIdx < 0) return false;
    const endIdx = Math.min(slots.length, startIdx + duration);
    for (let i = startIdx; i < endIdx; i++){
      const p = slots[i].querySelector('.pill');
      if (p && p !== ignorePill) return false;
    }
    return true;
  }

  // ===== Pointer Drag (works on desktop + mobile) =====
  let dragState = null; // {type:'palette'|'event', sourceEl, ghost, offsetY, offsetX}
  let lastDeleted = null;

  function startDragFromPalette(card, clientX, clientY){
    const ghost = card.cloneNode(true);
    ghost.classList.add('drag-ghost');
    ghost.style.width = (card.getBoundingClientRect().width) + 'px';
    document.body.appendChild(ghost);

    dragState = {
      type:'palette',
      sourceEl: card,
      ghost,
      action: card.dataset.action || card.textContent.trim(),
      color: getComputedStyle(card).backgroundColor,
      offsetX: 0,
      offsetY: 0
    };
    moveGhost(clientX, clientY);
  }

  function startDragEvent(pill, clientX, clientY){
    pill = ensurePill(pill);
    const rect = pill.getBoundingClientRect();
    const ghost = pill.cloneNode(true);
    ghost.classList.add('drag-ghost');
    ghost.style.width = rect.width + 'px';
    ghost.style.height = rect.height + 'px';
    document.body.appendChild(ghost);

    dragState = {
      type:'event',
      sourceEl: pill,
      ghost,
      action: pill.dataset.action,
      color: pill.style.backgroundColor || getComputedStyle(pill).backgroundColor,
      duration: parseInt(pill.dataset.duration||'1',10),
      fromSlot: pill.parentElement,
      offsetX: clientX - rect.left,
      offsetY: clientY - rect.top
    };
    moveGhost(clientX, clientY);

    // Temporarily remove from its slot so you can drop elsewhere without blocking yourself.
    if (pill.parentElement && pill.parentElement.classList.contains('slot')){
      pill.parentElement.removeChild(pill);
    }
  }

  function moveGhost(x,y){
    if (!dragState) return;
    dragState.ghost.style.left = x + 'px';
    dragState.ghost.style.top = y + 'px';
  }

  function clearHighlights(){
    document.querySelectorAll('.slot.highlight').forEach(s=>s.classList.remove('highlight'));
  }

  function highlightSlotUnderPointer(x,y){
    clearHighlights();
    const slot = slotFromPoint(x,y);
    if (slot) slot.classList.add('highlight');
    return slot;
  }

  function finishDrag(clientX, clientY){
    if (!dragState) return;

    const slot = slotFromPoint(clientX, clientY);
    clearHighlights();

    const overTrash = (() => {
      const tr = trash.getBoundingClientRect();
      return clientX >= tr.left && clientX <= tr.right && clientY >= tr.top && clientY <= tr.bottom;
    })();

    // Drop into trash
    if (overTrash){
      if (dragState.type === 'event'){
        lastDeleted = { pill: dragState.sourceEl, slot: dragState.fromSlot };
        showToast();
      }
      cleanupDrag();
      return;
    }

    // Valid drop onto a slot?
    if (slot){
      if (dragState.type === 'palette'){
        const pill = document.createElement('div');
        pill.className = 'pill';
        pill.style.backgroundColor = dragState.color;
        pill.dataset.action = dragState.action;
        pill.dataset.duration = '1';
        ensurePill(pill);
        setPillHeight(pill);

        // place at slot if empty
        if (canPlace(slot, 1, null)){
          slot.appendChild(pill);
          refreshLabel(pill, slot);
        }
      } else {
        const pill = dragState.sourceEl;
        pill.style.backgroundColor = dragState.color;
        pill.dataset.action = dragState.action;
        pill.dataset.duration = String(dragState.duration);
        ensurePill(pill);
        setPillHeight(pill);

        if (canPlace(slot, dragState.duration, pill)){
          slot.appendChild(pill);
          refreshLabel(pill, slot);
        } else {
          // revert to original position if cannot place
          if (dragState.fromSlot) dragState.fromSlot.appendChild(pill);
          refreshLabel(pill, dragState.fromSlot);
        }
      }
    } else {
      // not dropped on slot -> revert if was an event
      if (dragState.type === 'event' && dragState.fromSlot){
        dragState.fromSlot.appendChild(dragState.sourceEl);
        refreshLabel(dragState.sourceEl, dragState.fromSlot);
      }
    }

    cleanupDrag();
  }

  function cleanupDrag(){
    if (!dragState) return;
    try{ dragState.ghost.remove(); }catch(_){}
    dragState = null;
    trash.classList.remove('hover');
  }

  // Pointer handlers for dragging
  function onPointerMove(e){
    if (!dragState) return;
    moveGhost(e.clientX, e.clientY);
    highlightSlotUnderPointer(e.clientX, e.clientY);

    // trash hover
    const tr = trash.getBoundingClientRect();
    const overTrash = e.clientX >= tr.left && e.clientX <= tr.right && e.clientY >= tr.top && e.clientY <= tr.bottom;
    trash.classList.toggle('hover', overTrash);
  }
  function onPointerUp(e){
    if (!dragState) return;
    finishDrag(e.clientX, e.clientY);
    window.removeEventListener('pointermove', onPointerMove);
    window.removeEventListener('pointerup', onPointerUp);
  }

  // Start drag from palette or event (but NOT the resize handle)
  document.addEventListener('pointerdown', (e) => {
    const isHandle = e.target.classList.contains('handle');
    if (isHandle) return; // resize handled separately

    const card = e.target.closest('.card');
    const pill = e.target.closest('.pill');

    if (card){
      e.preventDefault();
      startDragFromPalette(card, e.clientX, e.clientY);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      return;
    }
    if (pill){
      e.preventDefault();
      startDragEvent(pill, e.clientX, e.clientY);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      return;
    }
  });

  // ===== Unlimited Resize (delegated) =====
  let resizeState = null; // {pill, slot, startY, startDur, startIdx, slots}
  function beginResize(pill, clientY){
    pill = ensurePill(pill);
    const slot = pill.parentElement;
    if (!slot || !slot.classList.contains('slot')) return;

    const slots = allSlots();
    const startIdx = slots.indexOf(slot);
    const startDur = Math.max(1, parseInt(pill.dataset.duration||'1',10));

    resizeState = { pill, slot, startY: clientY, startDur, startIdx, slots };
    pill.style.cursor = 'ns-resize';
  }

  function doResize(clientY){
    if (!resizeState) return;
    const { pill, slot, startY, startDur, startIdx, slots } = resizeState;
    const delta = Math.round((clientY - startY) / SLOT_H);
    let desired = startDur + delta;

    // growing: cap at next occupied slot & 8 hours (32 slots)
    if (delta > 0){
      let nextIdx = slots.length;
      for (let i = startIdx + 1; i < slots.length; i++){
        const p = slots[i].querySelector('.pill');
        if (p && p !== pill){ nextIdx = i; break; }
      }
      desired = Math.min(desired, nextIdx - startIdx, 32);
    }
    // shrinking always allowed down to 1 slot
    desired = Math.max(1, desired);

    // Also ensure we don't overlap by current span
    // (shrinking cannot create overlap; growing already capped)
    pill.dataset.duration = String(desired);
    setPillHeight(pill);
    refreshLabel(pill, slot);
  }

  function endResize(){
    if (!resizeState) return;
    resizeState.pill.style.cursor = 'grab';
    resizeState = null;
    window.removeEventListener('pointermove', onResizeMove);
    window.removeEventListener('pointerup', onResizeUp);
  }

  function onResizeMove(e){ doResize(e.clientY); }
  function onResizeUp(){ endResize(); }

  document.addEventListener('pointerdown', (e) => {
    if (!e.target.classList.contains('handle')) return;
    e.preventDefault(); e.stopPropagation();
    const pill = e.target.closest('.pill');
    beginResize(pill, e.clientY);
    window.addEventListener('pointermove', onResizeMove);
    window.addEventListener('pointerup', onResizeUp);
  });

  // ===== Toast Undo =====
  function showToast(){
    toast.classList.add('show');
    setTimeout(()=>toast.classList.remove('show'), 5000);
  }
  undoBtn.addEventListener('click', () => {
    if (!lastDeleted) return;
    const { pill, slot } = lastDeleted;
    if (slot && canPlace(slot, parseInt(pill.dataset.duration||'1',10), pill)){
      slot.appendChild(pill);
      refreshLabel(pill, slot);
    }
    lastDeleted = null;
    toast.classList.remove('show');
  });

  // ===== Export ICS =====
  exportBtn.addEventListener('click', () => {
    const dateStr = datePicker.value;
    if (!dateStr){ alert('Pick a date first'); return; }

    const evs = [];
    const slots = allSlots();
    for (const slot of slots){
      const pill = slot.querySelector('.pill');
      if (!pill) continue;

      const dur = Math.max(1, parseInt(pill.dataset.duration||'1',10));
      const sHM = slot.dataset.hm;
      const startMin = parseInt(sHM.slice(0,2),10)*60 + parseInt(sHM.slice(2),10);
      const endMin = startMin + dur*15;

      const dtStart = new Date(dateStr + 'T00:00:00');
      dtStart.setHours(Math.floor(startMin/60), startMin%60, 0, 0);
      const dtEnd = new Date(dateStr + 'T00:00:00');
      dtEnd.setHours(Math.floor(endMin/60), endMin%60, 0, 0);

      const fmt = (d) => d.toISOString().replace(/[-:]/g,'').replace(/\.\d{3}/,'');
      const safeSummary = (pill.dataset.action||'Event').replace(/\n/g,' ').trim();

      evs.push(
`BEGIN:VEVENT
DTSTART:${fmt(dtStart)}
DTEND:${fmt(dtEnd)}
SUMMARY:${safeSummary}
END:VEVENT`
      );
    }

    if (!evs.length){ alert('No events to export'); return; }

    const ics =
`BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
PRODID:-//DailyPlanner//EN
${evs.join('\n')}
END:VCALENDAR`;

    const blob = new Blob([ics], {type:'text/calendar;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'daily_schedule.ics';
    document.body.appendChild(a);
    a.click();
    a.remove();
  });

});
</script>
</body>
</html>
